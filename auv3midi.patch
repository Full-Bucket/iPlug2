diff --git a/IPlug/AUv3/IPlugAUv3.mm b/IPlug/AUv3/IPlugAUv3.mm
index eb77a9383d2b151fcbf8e1e058591ff7bbefa841..0cd629ec851336d5399bd3b44df24dd3651aceec 100644
--- a/IPlug/AUv3/IPlugAUv3.mm
+++ b/IPlug/AUv3/IPlugAUv3.mm
@@ -72,51 +72,53 @@ bool IPlugAUv3::SendSysEx(const ISysEx& msg)
   return [(__bridge IPLUG_AUAUDIOUNIT*) mAUAudioUnit sendMidiData: sampleTime : msg.mSize : msg.mData];
 }
 
-//void IPlugAUv3::HandleOneEvent(AURenderEvent const *event, AUEventSampleTime startTime)
-//{
-//  switch (event->head.eventType)
-//  {
-//    case AURenderEventParameter:
-//    case AURenderEventParameterRamp:
-//    {
-//      AUParameterEvent const& paramEvent = event->parameter;
-//      const int paramIdx = GetParamIdx(paramEvent.parameterAddress);
-//      const double value = (double) paramEvent.value;
-//      const int sampleOffset = (int) (paramEvent.eventSampleTime - startTime);
-//      ENTER_PARAMS_MUTEX
-//      GetParam(paramIdx)->Set(value);
-//      LEAVE_PARAMS_MUTEX
-//      OnParamChange(paramIdx, EParamSource::kHost, sampleOffset);
-//      break;
-//    }
-//
-//    case AURenderEventMIDI:
-//    {
-//      IMidiMsg msg;
-//      msg.mStatus = event->MIDI.data[0];
-//      msg.mData1 = event->MIDI.data[1];
-//      msg.mData2 = event->MIDI.data[2];
-//      msg.mOffset = (int) (event->MIDI.eventSampleTime - startTime);
-//      ProcessMidiMsg(msg);
-//      mMidiMsgsFromProcessor.Push(msg);
-//      break;
-//    }
-//    default:
-//      break;
-//  }
-//}
-//
-//void IPlugAUv3::PerformAllSimultaneousEvents(AUEventSampleTime now, AURenderEvent const *&event)
-//{
-//  do {
-//    HandleOneEvent(event, now);
-//
-//    // Go to next event.
-//    event = event->head.next;
-//
-//    // While event is not null and is simultaneous (or late).
-//  } while (event && event->head.eventSampleTime <= now);
-//}
+void IPlugAUv3::HandleOneEvent(AURenderEvent const* pEvent, AUEventSampleTime startTime)
+{
+  switch (pEvent->head.eventType)
+  {
+    case AURenderEventParameter:
+    case AURenderEventParameterRamp:
+    {
+      const AUParameterEvent& paramEvent = pEvent->parameter;
+
+      if (paramEvent.parameterAddress < NParams())
+      {
+        const int paramIdx = GetParamIdx(paramEvent.parameterAddress);
+
+        const double value = (double) paramEvent.value;
+        const int sampleOffset = (int) (paramEvent.eventSampleTime - startTime);
+        ENTER_PARAMS_MUTEX
+        GetParam(paramIdx)->Set(value);
+        LEAVE_PARAMS_MUTEX
+        OnParamChange(paramIdx, EParamSource::kHost, sampleOffset);
+      }
+    }
+    case AURenderEventMIDI:
+    {
+      const AUMIDIEvent& midiEvent = pEvent->MIDI;
+
+      IMidiMsg midiMsg = {static_cast<int>(midiEvent.eventSampleTime - startTime), midiEvent.data[0], midiEvent.data[1], midiEvent.data[2] };
+      
+      midiMsg.PrintMsg();
+      ProcessMidiMsg(midiMsg);
+      mMidiMsgsFromProcessor.Push(midiMsg);
+    }
+    default:
+      break;
+  }
+}
+
+void IPlugAUv3::PerformAllSimultaneousEvents(AUEventSampleTime now, AURenderEvent const *&event)
+{
+  do {
+    HandleOneEvent(event, now);
+
+    // Go to next event.
+    event = event->head.next;
+
+    // While event is not null and is simultaneous (or late).
+  } while (event && event->head.eventSampleTime <= now);
+}
 
 void IPlugAUv3::ProcessWithEvents(AudioTimeStamp const* pTimestamp, uint32_t frameCount, AURenderEvent const* pEvents, ITimeInfo& timeInfo)
 {
@@ -128,92 +130,52 @@ void IPlugAUv3::ProcessWithEvents(AudioTimeStamp const* pTimestamp, uint32_t fra
     ProcessMidiMsg(midiMsg);
   }
   
+  //Output SYSEX from the editor, which has bypassed ProcessSysEx()
+  while (mSysExDataFromEditor.Pop(mSysexBuf))
+  {
+    ISysEx smsg {mSysexBuf.mOffset, mSysexBuf.mData, mSysexBuf.mSize};
+    SendSysEx(smsg);
+  }
+  
   mLastTimeStamp = *pTimestamp;
   AUEventSampleTime now = AUEventSampleTime(pTimestamp->mSampleTime);
   uint32_t framesRemaining = frameCount;
-  
-  for (const AURenderEvent* pEvent = pEvents; pEvent != nullptr; pEvent = pEvent->head.next)
-  {
-    switch (pEvent->head.eventType)
-    {
-      case AURenderEventMIDI:
-      {
-        const AUMIDIEvent& midiEvent = pEvent->MIDI;
 
-        midiMsg = {static_cast<int>(midiEvent.eventSampleTime - now), midiEvent.data[0], midiEvent.data[1], midiEvent.data[2] };
-        ProcessMidiMsg(midiMsg);
-        mMidiMsgsFromProcessor.Push(midiMsg);
-      }
-      break;
+  AURenderEvent const* pEvent = pEvents;
 
-      case AURenderEventParameter:
-      case AURenderEventParameterRamp:
-      {
-        const AUParameterEvent& paramEvent = pEvent->parameter;
-        
-        if (paramEvent.parameterAddress < NParams())
-        {
-          const int paramIdx = GetParamIdx(paramEvent.parameterAddress);
-          
-          const double value = (double) paramEvent.value;
-          const int sampleOffset = (int) (paramEvent.eventSampleTime - now);
-          ENTER_PARAMS_MUTEX
-          GetParam(paramIdx)->Set(value);
-          LEAVE_PARAMS_MUTEX
-          OnParamChange(paramIdx, EParamSource::kHost, sampleOffset);
-        }
-
-        break;
-      }
-      break;
+  while (framesRemaining > 0) {
+    // If there are no more events, we can process the entire remaining segment and exit.
+    if (pEvent == nullptr)
+    {
+      uint32_t const bufferOffset = frameCount - framesRemaining;
+      ENTER_PARAMS_MUTEX;
+      ProcessBuffersWithOffset(0.f, bufferOffset, framesRemaining);
+      LEAVE_PARAMS_MUTEX;
+      return;
+    }
+
+    // **** start late events late.
+    auto timeZero = AUEventSampleTime(0);
+    auto headEventTime = pEvent->head.eventSampleTime;
+    uint32_t const framesThisSegment = uint32_t(std::max(timeZero, headEventTime - now));
 
-      default:
-        break;
+    // Compute everything before the next event.
+    if (framesThisSegment > 0)
+    {
+      uint32_t const bufferOffset = frameCount - framesRemaining;
+      ENTER_PARAMS_MUTEX;
+      ProcessBuffersWithOffset(0.f, bufferOffset, framesThisSegment);
+      LEAVE_PARAMS_MUTEX;
+      
+      // Advance frames.
+      framesRemaining -= framesThisSegment;
+
+      // Advance time.
+      now += AUEventSampleTime(framesThisSegment);
     }
-  }
 
-  ENTER_PARAMS_MUTEX;
-  ProcessBuffers(0.f, framesRemaining); // what about bufferOffset
-  LEAVE_PARAMS_MUTEX;
-    
-  //Output SYSEX from the editor, which has bypassed ProcessSysEx()
-  while (mSysExDataFromEditor.Pop(mSysexBuf))
-  {
-    ISysEx smsg {mSysexBuf.mOffset, mSysexBuf.mData, mSysexBuf.mSize};
-    SendSysEx(smsg);
+    PerformAllSimultaneousEvents(now, pEvent);
   }
-  
-
-//  while (framesRemaining > 0) {
-//    // If there are no more events, we can process the entire remaining segment and exit.
-//    if (event == nullptr) {
-////      uint32_t const bufferOffset = frameCount - framesRemaining;
-// TODO - ProcessBuffers should be within param mutex lock
-//      ProcessBuffers(0.f, framesRemaining); // what about bufferOffset
-//      return;
-//    }
-//
-//    // **** start late events late.
-//    auto timeZero = AUEventSampleTime(0);
-//    auto headEventTime = event->head.eventSampleTime;
-//    uint32_t const framesThisSegment = uint32_t(std::max(timeZero, headEventTime - now));
-//
-//    // Compute everything before the next event.
-//    if (framesThisSegment > 0)
-//    {
-////      uint32_t const bufferOffset = frameCount - framesRemaining;
-// TODO - ProcessBuffers should be within param mutex lock
-//      ProcessBuffers(0.f, framesThisSegment); // what about bufferOffset
-//
-//      // Advance frames.
-//      framesRemaining -= framesThisSegment;
-//
-//      // Advance time.
-//      now += AUEventSampleTime(framesThisSegment);
-//    }
-//
-//    PerformAllSimultaneousEvents(now, event);
-//  }
 }
 
 // this is called on a secondary thread (not main thread, not audio thread)
diff --git a/IPlug/IPlugProcessor.h b/IPlug/IPlugProcessor.h
index dc628f08cac6e8634d4c22fbe6d21b77c474d6d9..03e3ac2d6b027577b596abc51d2a953b6ec5a8fc 100644
--- a/IPlug/IPlugProcessor.h
+++ b/IPlug/IPlugProcessor.h
@@ -265,6 +265,8 @@ protected:
   void PassThroughBuffers(PLUG_SAMPLE_DST type, int nFrames);
   void ProcessBuffers(PLUG_SAMPLE_SRC type, int nFrames);
   void ProcessBuffers(PLUG_SAMPLE_DST type, int nFrames);
+  void ProcessBuffersWithOffset(PLUG_SAMPLE_SRC type, int offset, int nFrames);
+  void ProcessBuffersWithOffset(PLUG_SAMPLE_DST type, int offset, int nFrames);
   void ProcessBuffersAccumulating(int nFrames); // only for VST2 deprecated method single precision
   void ZeroScratchBuffers();
   void SetSampleRate(double sampleRate) { mSampleRate = sampleRate; }
@@ -299,6 +301,8 @@ private:
   WDL_PtrList<IOConfig> mIOConfigs;
   /* Manages pointers to the actual data for each channel */
   WDL_TypedBuf<sample*> mScratchData[2];
+  WDL_TypedBuf<sample*> mOffsetScratchData[2];
+
   /* A list of IChannelData structures corresponding to every input/output channel */
   WDL_PtrList<IChannelData<>> mChannelData[2];
 protected: // these members are protected because they need to be access by the API classes, and don't want a setter/getter
diff --git a/IPlug/IPlugProcessor.cpp b/IPlug/IPlugProcessor.cpp
index c5dbc071dbf0b2625b8084bc3d8064b5b8d20744..a91f0583ef57211037b3e9b5ab5a1ea12d819c5c 100644
--- a/IPlug/IPlugProcessor.cpp
+++ b/IPlug/IPlugProcessor.cpp
@@ -35,6 +35,8 @@ IPlugProcessor::IPlugProcessor(const Config& config, EAPI plugAPI)
 
   mScratchData[ERoute::kInput].Resize(totalNInChans);
   mScratchData[ERoute::kOutput].Resize(totalNOutChans);
+  mOffsetScratchData[ERoute::kInput].Resize(totalNInChans);
+  mOffsetScratchData[ERoute::kOutput].Resize(totalNOutChans);
 
   sample** ppInData = mScratchData[ERoute::kInput].Get();
 
@@ -529,6 +531,36 @@ void IPlugProcessor::ProcessBuffers(PLUG_SAMPLE_SRC type, int nFrames)
   }
 }
 
+void IPlugProcessor::ProcessBuffersWithOffset(PLUG_SAMPLE_DST type, int offset, int nFrames)
+{
+  for (auto i=0; i<MaxNChannels(ERoute::kInput); i++) {
+    mOffsetScratchData[ERoute::kInput].Get()[i] = mScratchData[ERoute::kInput].Get()[i] + offset;
+  }
+  
+  for (auto i=0; i<MaxNChannels(ERoute::kOutput); i++) {
+    mOffsetScratchData[ERoute::kOutput].Get()[i] = mScratchData[ERoute::kOutput].Get()[i] + offset;
+  }
+  
+  ProcessBlock(mOffsetScratchData[ERoute::kInput].Get(), mOffsetScratchData[ERoute::kOutput].Get(), nFrames);
+}
+
+void IPlugProcessor::ProcessBuffersWithOffset(PLUG_SAMPLE_SRC type, int offset, int nFrames)
+{
+  ProcessBuffersWithOffset((PLUG_SAMPLE_DST) 0, offset, nFrames);
+  int i, n = MaxNChannels(ERoute::kOutput);
+  IChannelData<>** ppOutChannel = mChannelData[ERoute::kOutput].GetList();
+
+  for (i = 0; i < n; ++i, ++ppOutChannel)
+  {
+    IChannelData<>* pOutChannel = *ppOutChannel;
+
+    if (pOutChannel->mConnected)
+    {
+      CastCopy(pOutChannel->mIncomingData, *(pOutChannel->mData), nFrames);
+    }
+  }
+}
+
 void IPlugProcessor::ProcessBuffersAccumulating(int nFrames)
 {
   ProcessBuffers((PLUG_SAMPLE_DST) 0, nFrames);
diff --git a/IPlug/AUv3/IPlugAUv3.h b/IPlug/AUv3/IPlugAUv3.h
index 0d83ca80c70a72012e7dbe498ffee6712cf3f30c..5aa65dc846f36ef392f45fb854e676c34d5cdbf5 100644
--- a/IPlug/AUv3/IPlugAUv3.h
+++ b/IPlug/AUv3/IPlugAUv3.h
@@ -80,8 +80,8 @@ public:
   virtual void* GetDataFromExternal(int& dataSize) { return nullptr; }
 
 private:
-//  void HandleOneEvent(AURenderEvent const* event, int64_t startTime);
-//  void PerformAllSimultaneousEvents(int64_t now, AURenderEvent const*& event);
+  void HandleOneEvent(AURenderEvent const* event, int64_t startTime);
+  void PerformAllSimultaneousEvents(int64_t now, AURenderEvent const*& event);
   WDL_IntKeyedArray<uint64_t> mParamAddressMap;
   void* mAUAudioUnit = nullptr;
   AudioTimeStamp mLastTimeStamp;
